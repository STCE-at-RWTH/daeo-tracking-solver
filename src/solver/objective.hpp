#ifndef _FUNCTION_WRAPPER_HPP
#define _FUNCTION_WRAPPER_HPP

#include <concepts>
#include <tuple>
#include <vector>

#include "boost/numeric/interval.hpp"
#include "dco.hpp"

using std::vector;
// f()
template <typename FN, typename NUMERIC_T>
concept IsObjective = requires(FN f, NUMERIC_T t, NUMERIC_T x, vector<NUMERIC_T> y,
                               vector<boost::numeric::interval<NUMERIC_T>> y_int, vector<NUMERIC_T> p) {
    {
        f(t, x, y, p)
    } -> std::convertible_to<NUMERIC_T>;
};

template <typename FN>
class DAEOWrappedFunction
{
    FN const m_fn;

public:
    DAEOWrappedFunction(FN const &t_fn) : m_fn{t_fn} {};

    template <typename T, typename U>
    U value(T const t, T const x, vector<U> const &y, vector<T> const &p) const
    {
        return m_fn(t, x, y, p);
    }

    template <typename PT, typename AT>
    vector<AT> ddy(PT const t, PT const x, vector<AT> const &y, vector<PT> const &p) const
    {
        // define dco types and get a pointer to the tape
        // unsure how to use ga1sm to expand this to multithreaded programs
        using dco_mode_t = dco::ga1s<AT>;
        using active_t = dco_mode_t::type;
        dco::smart_tape_ptr_t<dco_mode_t> tape;
        tape->reset();

        // define active inputs
        vector<active_t> y_active(y.size());
        dco::value(y_active) = y;
        tape->register_variable(y_active);
        // and active outputs
        active_t h_active = m_fn(t, x, y_active, p);
        tape->register_output_variable(h_active);
        dco::derivative(h_active) = 1;
        tape->interpret_adjoint();
        std::vector<AT> dhdy(y.size());
        for (size_t i = 0; i < y.size(); i++)
        {
            dhdy[i] = dco::derivative(y_active[i]);
        }
        return dhdy;
    }

    template <typename PT, typename AT>
    AT ddx(PT const t, AT const x, vector<PT> const &y, vector<PT> const &p) const
    {
        using dco_mode_t = dco::gt1s<AT>;
        using active_t = dco_mode_t::type;
        active_t x_active;
        dco::value(x_active) = x;
        dco::derivative(x_active) = 1;
        return dco::derivative(m_fn(t, x, y, p));
    }

    template <typename PT, typename AT>
    vector<vector<AT>> d2dy2(PT const t, PT const x,
                             vector<AT> const &y, vector<PT> const &p) const
    {
        using dco_tangent_t = dco::gt1s<AT>::type;
        using dco_mode_t = dco::ga1s<dco_tangent_t>;
        using active_t = dco_mode_t::type;
        dco::smart_tape_ptr_t<dco_mode_t> tape;

        const size_t ndims = y.size();
        active_t h_active;
        vector<active_t> y_active(ndims);
        dco::passive_value(y_active) = y;
        tape->register_variable(y_active);
        auto start_position = tape->get_position();
        // vector<AT> dhdy(ndims);
        vector<vector<AT>> d2hdy2(ndims, vector<AT>(ndims));
        for (size_t hrow = 0; hrow < ndims; hrow++)
        {
            dco::derivative(dco::value(y_active[hrow])) = 1;      // wiggle y[hrow]
            h_active = m_fn(t, x, y_active, p);                   // compute h
            dco::value(dco::derivative(h_active)) = 1;            // set sensitivity to wobbles in h to 1
            // dhdy[hrow] = dco::derivative(dco::value(h_active));   // wobble in h generated by wiggling y[hrow]
            tape->interpret_adjoint_and_reset_to(start_position); // interpret and rewind the tape
            for (size_t hcol = 0; hcol < ndims; hcol++)
            {
                d2hdy2[hrow][hcol] = dco::derivative(dco::derivative(y_active[hcol]));
                // reset any accumulated values
                dco::derivative(dco::derivative(y_active[hcol])) = 0;
                dco::value(dco::derivative(y_active[hcol])) = 0;
            }
            dco::derivative(dco::value(y_active[hrow])) = 0; // no longer wiggling y[hrow]
        }
        return d2hdy2;
    }

    template <typename AT, typename PT>
    vector<AT> d2dxdy(PT const t, AT const x, vector<AT> const &y, vector<PT> const &p) const
    {
        using dco_tangent_t = dco::gt1s<AT>::type;
        using dco_mode_t = dco::ga1s<dco_tangent_t>;
        using active_t = dco_mode_t::type;
        dco::smart_tape_ptr_t<dco_mode_t> tape;
        active_t h_active;
        vector<active_t> y_active(y.size());
        active_t x_active;

        dco::passive_value(y_active) = y;
        dco::passive_value(x_active) = x;
        tape->register_variable(x_active);
        tape->register_variable(y_active);
        
        vector<AT> ddxddy(y.size());

        dco::derivative(dco::value(x_active)) = 1; // wiggle x
        h_active = m_fn(t, x_active, y_active, p); // compute h
        dco::value(dco::derivative(h_active)) = 1; // sensitivity to h is 1
        tape->interpret_adjoint();
        for (size_t i = 0; i < y.size(); i++)
        {
            ddxddy[i] = dco::derivative(dco::derivative(y_active)); // harvest d2dxdy
        }
        return ddxddy;
    }
};

#endif